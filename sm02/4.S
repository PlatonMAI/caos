// Напишите подпрограмму ‘partition’, которая в регистре RBX принимает адрес начала массива arr элементов типа int16_t, в регистре ESI их количество size (size > 1) и в регистре EDI знаковое значение pivot. Гарантируется, что элемент, равный pivot, в массиве существует.

// Перегруппируйте элементы массива таким образом, что в начале массива находятся элементы, для которых выполняется условие arr[i] <= pivot, а в конце массива — arr[i] >= pivot.

// То есть в итоговом массиве должен существовать такой индекс mid (0 <= mid < size) что arr[i] <= pivot для любого i < mid и arr[i] >= pivot для любого i >= mid.

// В регистре EDX верните mid.

// Соблюдайте стандартные соглашения о сохранении/восстановлении регистров.

// Например, если задан массив { 10 9 8 7 6 5 4 3 2 1 } и значение pivot == 5, возможным результатом будет массив { 1 2 3 4 6 5 7 8 9 10 } и значение mid == 4.


// Регистры получения и возврата были изменены для тестирования функции из Си


    .intel_syntax noprefix
    .global partition
partition:
    xor r8, r8 // l
    mov r9d, esi // r
    dec r9
loop:
    cmp r9, r8
    jle break

cmp_l:
    cmp [rdi + r8 * 2], dx
    jge cmp_r
    inc r8
    jmp loop
cmp_r:
    cmp [rdi + r9 * 2], dx
    jl swap
    dec r9
    jmp loop
swap:
    mov r10w, [rdi + r8 * 2]
    mov r11w, [rdi + r9 * 2]
    mov [rdi + r8 * 2], r11w
    mov [rdi + r9 * 2], r10w
    // inc r8
    // dec r9
    jmp loop

break:
    mov eax, r8d
    ret
